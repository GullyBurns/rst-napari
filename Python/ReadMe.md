# Python Code for Napari Plug-In Annotation
<hr>

## Requirements

The code requires the following packages:

* Python ver 3.8+
* [pygtrie](https://github.com/google/pygtrie), ver 2.4.2

On my machine, these are available in a Virtual Environment:

```
$> . ~/Home/Test/PyVenvs/Txf46x/bin/activate
$> ...
$> deactivate
```

## Detecting Ontology terms in Plugin Descriptions

This requires two data files:
* A file containing Ontology Terms, their Synonyms, and Partial Matches. 
  We currently use a CSV file generated by Michaela, which can be found at `../Data/programmatic napari-hub tagging - full terms,synonyms, partial phrases.csv`
* A file containing Plugin Names and Descriptions.

### Output Ontology Terms detected in all Plugins

```
$> python -m mentions.annotater annotate ../Data/programmatic\ napari-hub\ tagging\ -\ full\ terms\,synonyms\,\ partial\ phrases.csv ../Data/plugin_descriptions.csv ../Data/plugin_annotations.csv
```

Output is written to the file `../Data/plugin_annotations.csv` in CSV format.


### Pretty-print Ontology Term matches to a sample of Plugins

This shows where the matches were found in the description text. If plugins have a summary, it is added as the first line to the description.

```
$> python -m mentions.annotater sample ../Data/programmatic napari-hub tagging - full terms,synonyms, partial phrases.csv ../Data/plugin_descriptions.csv 2
```

Output is written to the terminal. The last argument specifies how many plugins to annotate.


## Python API

The code uses a [trie](https://en.wikipedia.org/wiki/Trie) data structure for fast exact match (aka dictionary lookup) 
of ontology terms, treated as word-sequences. 

The two main functions are:

* `mentions.annotater.build_ontology_trie_matcher()`: Load the ontology terms, and build the trie.
* `mentions.annotater.get_ont_matches()`: Given a plugin description as a text string, find ontology matches.

See `mentions.annotater.annotate_plugins()` for an example of how to use these functions.

The trie-based matcher `text.triematcher.TrieMatcher` supports 4 name types for each ontology entry:

* The Primary Name. The formal name of that entry.
* Acronyms.
* Synonyms.
* Partial names: a 'lower' category of synonyms.

The provided names, and the plugin description text, are tokenized using the same tokenizer 
(`text.entity_matcher.BasicRevMappedTokenizer`). Acronyms use a case-sensitive match, and all other name types are
matched without sensitivity to case. Finding greedy non-overlapping matches of names in the text seems to work the
best, with preference given to name types in the order shown above (user can change this order when building a 
`text.triematcher.TrieMatcher` instance).
